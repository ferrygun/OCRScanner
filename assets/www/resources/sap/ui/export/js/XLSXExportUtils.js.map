{"version":3,"sources":["webpack:///XLSXExportUtils.js","webpack:///webpack/bootstrap 875d289632d9da1d8916","webpack:///./client/src/export-utils.js","webpack:///./client/src/provider/ODataDataProvider.js","webpack:///./client/src/provider/RequestHandler.js","webpack:///./client/src/filesaver/FileSaver.js"],"names":["XLSXExportUtils","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","29","ODataDataProvider","FileSaver","oData","fetch","requestData","getConverter","saveFile","30","parseDate","sValue","array","date","offset","valueOf","jsonDateRE","test","exec","Date","parseInt","setUTCMinutes","getUTCMinutes","getTime","isFinite","parseDuration","vValue","__edmType","ms","parseTimeRE","parts","years","months","days","hours","minutes","seconds","parseFloat","getValue","oRow","oCol","value","keys","reduce","obj","key","type","convertData","aRows","aCols","forEach","col","row","getColsToConvert","mSettings","workbook","columns","result","Array","aKeys","split","length","push","getDataConverter","aColumns","fnProcessCallback","getUrl","iSkip","iTop","sNextUrl","mDataUrl","URI","parse","dataUrl","mNextUrl","query","aQuery","mQuery","keyValue","join","serialize","build","fnOnError","sMessage","error","fnOnDataReceived","oResult","aData","iFetchedRows","fPercent","iRemainingRows","mCallbackParams","bCancelled","results","isArray","iAvailableRows","iTotalRows","finished","progress","Math","round","__next","mRequest","min","iBatchSize","RequestHandler","sendRequest","then","catch","rows","fnConvertData","mDataSource","dataSource","count","MAX_ROWS","sizeLimit","batchSize","serviceUrl","url","mUri","path","slice","hash","fragment","method","useBatch","headers","cancel","31","oRequest","Error","sendBatchRequest","sendGetRequest","Promise","fnResolve","fnReject","xhr","XMLHttpRequest","onload","this","status","responseText","JSON","e","onerror","HTTP_ERROR_MSG","onabort","open","setRequestHeader","send","createGuid","replace","r","random","toString","boundary","body","aLines","iStart","iLength","iEnd","responseData","toLowerCase","32","blob","link","downloadSupported","fnSave","Blob","document","createElementNS","data","fileName","download","href","URL","createObjectURL","dispatchEvent","MouseEvent","reader","FileReader","onloadend","opened","window","location","readAsDataURL","navigator","msSaveOrOpenBlob"],"mappings":"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","file":"XLSXExportUtils.js","sourcesContent":["var XLSXExportUtils =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 29);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 29:\n/***/ (function(module, exports, __webpack_require__) {\n\n// Bundle all utilities into a single module \r\nvar ODataDataProvider = __webpack_require__(30);\r\nvar FileSaver = __webpack_require__(32);\r\n\r\nmodule.exports = {\r\n\toData: {\r\n\t\tfetch: ODataDataProvider.requestData,\r\n\t\tgetConverter: ODataDataProvider.getConverter\r\n\t},\r\n\tsaveFile: FileSaver.saveFile\r\n};\n\n/***/ }),\n\n/***/ 30:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar RequestHandler = __webpack_require__(31);\r\n\r\nvar MAX_ROWS = 1000000; // 1,000,000\r\n\r\n/**\r\n * OData interface for requesting chunked data.\r\n */\r\n\r\n/** START Copied and adapted from datajs * */\r\n/* The regular expression corresponds to something like this:\r\n * /Date(123+60)/\r\n *\r\n * This first number is date ticks, the + may be a - and is optional,\r\n * with the second number indicating a timezone offset in minutes.\r\n *\r\n * On the wire, the leading and trailing forward slashes are\r\n * escaped without being required to so the chance of collisions is reduced;\r\n * however, by the time we see the objects, the characters already\r\n * look like regular forward slashes.\r\n*/\r\nvar jsonDateRE = /^\\/Date\\((-?\\d+)(\\+|-)?(\\d+)?\\)\\/$/;\r\n\r\n/**\r\n * Retrieves a OData date string and converts it to its\r\n * corresponding UNIX timestamp. The timestamp represents the\r\n * amount of milliseconds from or to 01.01.1970 00:00:00 UTC.\r\n *\r\n * @param {string|number/object} sValue - Date that needs to be converted\r\n * @return {number} The UNIX timestamp or a JavaScript Date object\r\n * @private\r\n */\r\nfunction parseDate(sValue) {\r\n\tvar array, date, offset;\r\n\r\n\tif (sValue == null) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Date, String, Number object\r\n\tif (typeof sValue === \"object\") {\r\n\t\tsValue = sValue.valueOf();\r\n\t}\r\n\r\n\t// Timestamp as a number\r\n\tif (typeof sValue === \"number\") {\r\n\t\treturn sValue;\r\n\t}\r\n\r\n\t// Date in oData format\r\n\tif (jsonDateRE.test(sValue)) {\r\n\t\t/* The RegExp matches up to 4 groups:\r\n\t\t * 0: Full match\r\n\t\t * 1: Timestamp (mandatory)\r\n\t\t * 2: Timezone offset sign [ + | - ] (optional)\r\n\t\t * 3: Timezone offset minutes [0-9]{2,3} (optional)\r\n\t\t */\r\n\t\tarray = jsonDateRE.exec(sValue);\r\n\t\tdate = new Date(parseInt(array[1], 10));\r\n\r\n\t\tif (array[2] && array[3]) {\r\n\t\t\toffset = parseInt(array[2] + array[3], 10);\r\n\t\t\tdate.setUTCMinutes(date.getUTCMinutes() - offset);\r\n\t\t}\r\n\t\treturn date.getTime();\r\n\t} \r\n\r\n\t// Timestamp as a string\r\n\tif (isFinite(sValue)) {\r\n\t\treturn parseInt(sValue, 10);\r\n\t}\r\n\r\n\t// Date as a string\r\n\tdate = new Date(sValue);\r\n\tif (isFinite(date)) {\r\n\t\treturn date.getTime();\r\n\t}\r\n\r\n\t// Unrecognized date\r\n\treturn null;\r\n}\r\n\r\n// The captured indices for this expression are:\r\n// 0       - complete input\r\n// 1       - direction\r\n// 2,3,4   - years, months, days\r\n// 5,6,7,8 - hours, minutes, seconds, miliseconds\r\nvar parseTimeRE = /^([+-])?P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(?:\\.(\\d+))?S)?)?/;\r\n\r\n\r\n/**\r\n * Extracts the milliseconds if the value is a date/time instance or formatted string.\r\n * @param {any} vValue\r\n *   the value (may be <code>undefined</code> or <code>null</code>)\r\n * @returns {any}\r\n *   the number of milliseconds or the value itself\r\n */\r\nfunction parseDuration(vValue) {\r\n\tif (vValue instanceof Date) {\r\n\t\treturn vValue.getTime();\r\n\t} else if (vValue && vValue.__edmType === \"Edm.Time\") {\r\n\t\treturn vValue.ms;\r\n\t} else if (typeof vValue === \"string\" && parseTimeRE.test(vValue)) {\r\n\t\t/// <summary>Parses a string in xsd:duration format.</summary>\r\n\t\t/// <param name=\"duration\" type=\"String\">Duration value.</param>\r\n\t\t/// <remarks>\r\n\t\t/// This method will return the input, if the input string has a year or a month component.\r\n\t\t/// </remarks>\r\n\t\t/// <returns type=\"Object\">Object representing the time</returns>\r\n\r\n\t\tvar parts = parseTimeRE.exec(vValue);\r\n\r\n\t\tvar years = parts[2] || \"0\";\r\n\t\tvar months = parts[3] || \"0\";\r\n\t\tvar days = parseInt(parts[4] || 0, 10);\r\n\t\tvar hours = parseInt(parts[5] || 0, 10);\r\n\t\tvar minutes = parseInt(parts[6] || 0, 10);\r\n\t\tvar seconds = parseFloat(parts[7] || 0);\r\n\r\n\t\t// Unsupported duration value for Edm.Time OData spec\r\n\t\tif (years !== \"0\" || months !== \"0\") {\r\n\t\t\treturn vValue;\r\n\t\t}\r\n\r\n\t\tvar ms = parts[8];\r\n\t\tif (!ms) {\r\n\t\t\tms = 0;\r\n\t\t} else {\r\n\t\t\t// parse ms duration value ignoring any precision/scale as that part is anyway ignored by JS Date conversion!\r\n\t\t\tms = parseFloat(\"0.\" + ms) * 1000;\r\n\t\t}\r\n\r\n\t\tms += seconds * 1000 + minutes * 60000 + hours * 3600000 + days * 86400000;\r\n\r\n\t\tif (parts[1] === \"-\") {\r\n\t\t\tms = -ms;\r\n\t\t}\r\n\t\tvValue = ms;\r\n\t}\r\n\r\n\treturn vValue;\r\n}\r\n\r\n/** END Copied from datajs * */\r\n\r\n/**\r\n * Gets converted property value from raw data.\r\n * Navigation properties are parsed. Data type values are converted from OData format to JS format (for date types).\r\n * \r\n * @param {Object} oRow - Raw data row\r\n * @param {Object} oCol - Column information\r\n * @param {Array} oCol.keys - Property name or key path for navigation properties\r\n * @param {string} oCol.type - Column data type\r\n * \r\n * @private\r\n */\r\nfunction getValue(oRow, oCol) {\r\n\t// Get property value\r\n\tvar value = oCol.keys.reduce(function (obj, key) {\r\n\t\treturn obj && obj[key];\r\n\t}, oRow);\r\n\t// Convert, if needed.\r\n\tif (value) {\r\n\t\tif (oCol.type === 'date' || oCol.type === 'datetime') {\r\n\t\t\tvalue = parseDate(value);\r\n\t\t} else if (oCol.type === 'time') {\r\n\t\t\tvalue = parseDuration(value);\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Function to process the JSON result array from a ODataService.\r\n * \r\n * @param {Array} aRows - Data array that contains the received data\r\n * @param {Array} aCols - Columns that need to be converted\r\n * \r\n * @private\r\n */\r\nfunction convertData(aRows, aCols) {\r\n\taCols.forEach(function (col) {\r\n\t\taRows.forEach(function (row) {\r\n\t\t\trow[col.property] = getValue(row, col);\r\n\t\t});\r\n\t});\r\n\treturn aRows;\r\n}\r\n\r\n/**\r\n * The function returns array of columns that need special conversion for values.\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @private\r\n */\r\nfunction getColsToConvert(mSettings) {\r\n\treturn mSettings.workbook.columns.reduce(function (result, col) {\r\n\r\n\t\t// Handle aggregated properties and single properties\r\n\t\tvar properties = col.property instanceof Array ? col.property : [col.property];\r\n\r\n\t\tproperties.forEach(function(property) {\r\n\t\t\t// Convert navigation property and date fields\r\n\t\t\tvar aKeys = property.split(\"/\");\r\n\t\t\tif (aKeys.length > 1 || col.type === 'date' || col.type === 'datetime' ||  col.type === 'time') {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tproperty: property,\r\n\t\t\t\t\tkeys: aKeys,\r\n\t\t\t\t\ttype: col.type\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t}, []);\r\n}\r\n\r\n/**\r\n * The function returns a conversion function for raw data.\r\n *\r\n * @param {Object} mSettings Configuration object\r\n * @returns {function} Conversion function\r\n */\r\nfunction getDataConverter(mSettings) {\r\n\tvar aColumns = getColsToConvert(mSettings);\r\n\treturn function(aRows) {\r\n\t\treturn convertData(aRows, aColumns);\r\n\t};\r\n}\r\n\r\n/**\r\n * The function requests several chunks of data until the maximum\r\n * amount of data is fetched.\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n */\r\nfunction requestData(mSettings, fnProcessCallback) {\r\n\tvar iAvailableRows = 0;\r\n\tvar mDataSource = mSettings.dataSource;\r\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\r\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\r\n\tvar bCancelled = false;\r\n\tvar dataUrl = mDataSource.dataUrl;\r\n\tvar fnConvertData = getDataConverter(mSettings);\r\n\tvar mRequest;\r\n\r\n\tfunction cleanUrl (url) {\r\n\t\tif (!url) return \"\";\r\n\t\tvar mUri = URI.parse(url);\r\n\t\tmUri.path = mUri.path || \"\";\r\n\t\tif (mUri.path.slice(-1) !== \"/\") {\r\n\t\t\tmUri.path = mUri.path + \"/\";\r\n\t\t}\r\n\t\tdelete mUri.query;\r\n\t\tdelete mUri.hash;\r\n\t\tdelete mUri.fragment;\r\n\t\treturn (URI.serialize || URI.build)(mUri);\r\n\t}\r\n\r\n\t// Get download URL for the next batch\r\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\r\n\t\tvar mDataUrl = URI.parse(dataUrl);\r\n\t\tif (sNextUrl) { // use __next from server, replace origin if proxy was used\r\n\t\t\tvar mNextUrl = URI.parse(sNextUrl);\r\n\t\t\tmDataUrl.query = mNextUrl.query;\r\n\t\t} else { // use $skip and $top\r\n\t\t\tvar aQuery = (mDataUrl.query || \"\").split(\"&\");\r\n\t\t\tvar mQuery = {};\r\n\t\t\taQuery.forEach(function(query) {\r\n\t\t\t\tvar keyValue = query.split(\"=\");\r\n\t\t\t\tif (keyValue[0]) {\r\n\t\t\t\t\tmQuery[keyValue[0]] = keyValue[1];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tmQuery[\"$skip\"] = iSkip;\r\n\t\t\tmQuery[\"$top\"] = iTop;\r\n\t\t\taQuery = [];\r\n\t\t\tfor (var key in mQuery) {\r\n\t\t\t\taQuery.push(key + (mQuery[key] == null ? \"\" : \"=\" + mQuery[key]));\r\n\t\t\t}\r\n\t\t\tmDataUrl.query = aQuery.join(\"&\");\r\n\t\t}\r\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes request handler exceptions.\r\n\t *\r\n\t * @param {string} sMessage - Error message.\r\n\t */\r\n\tfunction fnOnError(sMessage) {\r\n\t\tfnProcessCallback({\r\n\t\t\terror: sMessage\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes the received data. Processing\r\n\t * the data before executing the callback function allows to\r\n\t * apply transformations to the data.\r\n\t *\r\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\r\n\t */\r\n\tfunction fnOnDataReceived(oResult) {\r\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\r\n\t\tvar mCallbackParams = {};\r\n\r\n\t\tif (bCancelled) {\r\n\t\t\treturn; // cancelled by the application\r\n\t\t}\r\n\r\n\t\taData = (oResult && oResult.d && (oResult.d.results || oResult.d)) || oResult;\r\n\t\taData = (Array.isArray(aData)) ? aData : [];\r\n\t\tiFetchedRows = aData.length;\r\n\r\n\t\tiAvailableRows += iFetchedRows;\r\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\r\n\t\tfPercent = iAvailableRows / iTotalRows;\r\n\r\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\r\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\r\n\r\n\t\t// check if next url is provided\r\n\t\tsNextUrl = oResult && oResult.d && oResult.d.__next || null;\r\n\r\n\t\tif (!mCallbackParams.finished) {\r\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\r\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\r\n\t\t\tRequestHandler\r\n\t\t\t\t.sendRequest(mRequest)\r\n\t\t\t\t.then(fnOnDataReceived)\r\n\t\t\t\t.catch(fnOnError);\r\n\t\t}\r\n\r\n\t\tmCallbackParams.rows = fnConvertData(aData); // normalize data\r\n\t\tfnProcessCallback(mCallbackParams); // Return result\r\n\t}\r\n\r\n\t// Execution\r\n\tmRequest = {\r\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\r\n\t\tdataUrl: getUrl(0, iBatchSize),\r\n\t\tmethod: mDataSource.useBatch ? \"BATCH\" : \"GET\",\r\n\t\theaders: mDataSource.headers\r\n\t};\r\n\r\n\tRequestHandler\r\n\t\t.sendRequest(mRequest)\r\n\t\t.then(fnOnDataReceived)\r\n\t\t.catch(fnOnError);\r\n\r\n\treturn {cancel: function() {bCancelled = true;}};\r\n}\r\n\r\nmodule.exports = {\r\n\trequestData: requestData,\r\n\tgetConverter: getDataConverter\r\n};\n\n/***/ }),\n\n/***/ 31:\n/***/ (function(module, exports) {\n\n/**\r\n * Returns a promise that is resolved once the data is fetched\r\n */\r\n\r\nvar HTTP_ERROR_MSG = 'HTTP connection error';\r\n\r\n/**\r\n * This method creates an XMLHttpRequest from the provided\r\n * configuration and requests the data from the backend. The\r\n * configuration is configured to use OData services.\r\n *\r\n * @param {Object} oRequest - Request configuration object\r\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\r\n * @param {string} oRequest.url - References the resource URL that gets invoked\r\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\r\n */\r\nfunction sendRequest(oRequest) {\r\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\r\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\r\n\t}\r\n\r\n\treturn (oRequest.method === \"BATCH\" && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\r\n}\r\n\r\nfunction sendGetRequest(oRequest) {\r\n\treturn new Promise(function (fnResolve, fnReject) {\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\txhr.onload = function () {\r\n\t\t\tif (this.status >= 400) {\r\n\t\t\t\tfnReject(this.responseText);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\r\n\t\t\t} catch (e) {\r\n\t\t\t\tfnReject(\"Server response is not a valid JSON:\\n\" + this.responseText);\r\n\t\t\t}\r\n\t\t};\r\n\t\txhr.onerror = function () {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.onabort = function () {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.open(\"GET\", oRequest.dataUrl, true);\r\n\t\txhr.setRequestHeader(\"accept\", \"application/json\");\r\n\t\txhr.send();\r\n\t});\r\n}\r\n\r\nfunction createGuid() {\r\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n\t\tvar r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\r\n\t\treturn v.toString(16);\r\n\t});\r\n}\r\n\r\nfunction sendBatchRequest(oRequest) {\r\n\treturn new Promise(function (fnResolve, fnReject) {\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\tvar boundary = \"batch_\" + createGuid();\r\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\r\n\t\tvar body = [];\r\n\r\n\t\txhr.onload = function () {\r\n\t\t\tvar responseText = this.responseText;\r\n\t\t\tvar aLines = this.responseText.split(\"\\r\\n\");\r\n\r\n\t\t\t//TBD: check return codes\r\n\t\t\tvar iStart = 0, iLength = aLines.length, iEnd = iLength - 1;\r\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0,1) !== \"{\") {\r\n\t\t\t\tiStart++;\r\n\t\t\t}\r\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== \"}\") {\r\n\t\t\t\tiEnd--;\r\n\t\t\t}\r\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\r\n\t\t\tresponseText = aLines.join(\"\\r\\n\");\r\n\r\n\t\t\ttry {\r\n\t\t\t\tvar responseData = JSON.parse(responseText);\r\n\t\t\t\tfnResolve(responseData);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tfnReject(\"Server response is not a valid JSON\");\r\n\t\t\t}\r\n\t\t};\r\n\t\txhr.onerror = function () {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.onabort = function () {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\t// create request\r\n\t\txhr.open(\"POST\", oRequest.serviceUrl + \"$batch\", true);\r\n\r\n\t\txhr.setRequestHeader(\"Accept\", \"multipart/mixed\");\r\n\t\txhr.setRequestHeader(\"Content-Type\", \"multipart/mixed;boundary=\" + boundary);\r\n\r\n\t\tfor (var key in oRequest.headers) {\r\n\t\t\tif (key.toLowerCase() != \"accept\") {\r\n\t\t\t\txhr.setRequestHeader(key, oRequest.headers[key]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbody.push(\"--\" + boundary);\r\n\t\tbody.push(\"Content-Type: application/http\");\r\n\t\tbody.push(\"Content-Transfer-Encoding: binary\");\r\n\t\tbody.push(\"\");\r\n\t\tbody.push(\"GET \" + getUrl + \" HTTP/1.1\");\r\n\t\tfor (var key in oRequest.headers) {\r\n\t\t\tbody.push(key + \":\" + oRequest.headers[key]);\r\n\t\t}\r\n\t\tbody.push(\"\");\r\n\t\tbody.push(\"\");\r\n\t\tbody.push(\"--\" + boundary + \"--\");\r\n\t\tbody.push(\"\");\r\n\t\tbody = body.join(\"\\r\\n\");\r\n\t\txhr.send(body);\r\n\t});\r\n}\r\n\r\nmodule.exports = { sendRequest: sendRequest };\n\n/***/ }),\n\n/***/ 32:\n/***/ (function(module, exports) {\n\n/**\r\n * The FileSaver allows to save browser generated files to\r\n * the local computer without using a proxy service.\r\n *\r\n * This class supports the latest version of the following browsers:\r\n *\r\n * Microsoft Internet Explorer 11\r\n * Microsoft Edge\r\n * Google Chrome\r\n * Mozilla Firefox\r\n * MacOS Safari\r\n * iOS Safari\r\n * Chrome for Android\r\n * SAP Fiori Client\r\n */\r\n\r\n/**\r\n * This function saves the provided Blob to the local file system.\r\n * The parameter name is optional and depending on the browser it\r\n * is not ensured that the filename can be applied. Google Chrome,\r\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\r\n * apply the filename correctly.\r\n *\r\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\r\n * @param {string} [name] - Filename of the file including the file extension\r\n */\r\nfunction saveFile(blob, name) {\r\n\tvar link, downloadSupported, fnSave;\r\n\r\n\t/* Ignore other formats than Blob */\r\n\tif (!(blob instanceof Blob)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\r\n\tdownloadSupported = 'download' in link;\r\n\r\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\r\n\tif (downloadSupported) {\r\n\t\tfnSave = function (data, fileName) {\r\n\t\t\tlink.download = fileName;\r\n\t\t\tlink.href = URL.createObjectURL(data);\r\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\r\n\t\t}\r\n\t}\r\n\r\n\t/* iOS Safari, MacOS Safari */\r\n\tif (typeof fnSave === 'undefined') {\r\n\t\tfnSave = function (data) {\r\n\t\t\tvar reader = new FileReader();\r\n\r\n\t\t\treader.onloadend = function () {\r\n\t\t\t\tvar opened, url;\r\n\r\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\r\n\t\t\t\topened = window.open(url, '_blank');\r\n\r\n\t\t\t\tif (!opened) {\r\n\t\t\t\t\twindow.location.href = url;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treader.readAsDataURL(blob);\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t * IE/Edge implementation\r\n\t *\r\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\r\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\r\n\t */\r\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\r\n\t\tfnSave = function (data, fileName) {\r\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\r\n\t\t};\r\n\t}\r\n\r\n\t/* Save file to device */\r\n\tfnSave(blob, name);\r\n}\r\n\r\nmodule.exports = { saveFile: saveFile };\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// XLSXExportUtils.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 29);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 875d289632d9da1d8916","// Bundle all utilities into a single module \r\nvar ODataDataProvider = require(\"./provider/ODataDataProvider.js\");\r\nvar FileSaver = require(\"./filesaver/FileSaver.js\");\r\n\r\nmodule.exports = {\r\n\toData: {\r\n\t\tfetch: ODataDataProvider.requestData,\r\n\t\tgetConverter: ODataDataProvider.getConverter\r\n\t},\r\n\tsaveFile: FileSaver.saveFile\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/export-utils.js\n// module id = 29\n// module chunks = 1","var RequestHandler = require('./RequestHandler.js');\r\n\r\nvar MAX_ROWS = 1000000; // 1,000,000\r\n\r\n/**\r\n * OData interface for requesting chunked data.\r\n */\r\n\r\n/** START Copied and adapted from datajs * */\r\n/* The regular expression corresponds to something like this:\r\n * /Date(123+60)/\r\n *\r\n * This first number is date ticks, the + may be a - and is optional,\r\n * with the second number indicating a timezone offset in minutes.\r\n *\r\n * On the wire, the leading and trailing forward slashes are\r\n * escaped without being required to so the chance of collisions is reduced;\r\n * however, by the time we see the objects, the characters already\r\n * look like regular forward slashes.\r\n*/\r\nvar jsonDateRE = /^\\/Date\\((-?\\d+)(\\+|-)?(\\d+)?\\)\\/$/;\r\n\r\n/**\r\n * Retrieves a OData date string and converts it to its\r\n * corresponding UNIX timestamp. The timestamp represents the\r\n * amount of milliseconds from or to 01.01.1970 00:00:00 UTC.\r\n *\r\n * @param {string|number/object} sValue - Date that needs to be converted\r\n * @return {number} The UNIX timestamp or a JavaScript Date object\r\n * @private\r\n */\r\nfunction parseDate(sValue) {\r\n\tvar array, date, offset;\r\n\r\n\tif (sValue == null) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Date, String, Number object\r\n\tif (typeof sValue === \"object\") {\r\n\t\tsValue = sValue.valueOf();\r\n\t}\r\n\r\n\t// Timestamp as a number\r\n\tif (typeof sValue === \"number\") {\r\n\t\treturn sValue;\r\n\t}\r\n\r\n\t// Date in oData format\r\n\tif (jsonDateRE.test(sValue)) {\r\n\t\t/* The RegExp matches up to 4 groups:\r\n\t\t * 0: Full match\r\n\t\t * 1: Timestamp (mandatory)\r\n\t\t * 2: Timezone offset sign [ + | - ] (optional)\r\n\t\t * 3: Timezone offset minutes [0-9]{2,3} (optional)\r\n\t\t */\r\n\t\tarray = jsonDateRE.exec(sValue);\r\n\t\tdate = new Date(parseInt(array[1], 10));\r\n\r\n\t\tif (array[2] && array[3]) {\r\n\t\t\toffset = parseInt(array[2] + array[3], 10);\r\n\t\t\tdate.setUTCMinutes(date.getUTCMinutes() - offset);\r\n\t\t}\r\n\t\treturn date.getTime();\r\n\t} \r\n\r\n\t// Timestamp as a string\r\n\tif (isFinite(sValue)) {\r\n\t\treturn parseInt(sValue, 10);\r\n\t}\r\n\r\n\t// Date as a string\r\n\tdate = new Date(sValue);\r\n\tif (isFinite(date)) {\r\n\t\treturn date.getTime();\r\n\t}\r\n\r\n\t// Unrecognized date\r\n\treturn null;\r\n}\r\n\r\n// The captured indices for this expression are:\r\n// 0       - complete input\r\n// 1       - direction\r\n// 2,3,4   - years, months, days\r\n// 5,6,7,8 - hours, minutes, seconds, miliseconds\r\nvar parseTimeRE = /^([+-])?P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(?:\\.(\\d+))?S)?)?/;\r\n\r\n\r\n/**\r\n * Extracts the milliseconds if the value is a date/time instance or formatted string.\r\n * @param {any} vValue\r\n *   the value (may be <code>undefined</code> or <code>null</code>)\r\n * @returns {any}\r\n *   the number of milliseconds or the value itself\r\n */\r\nfunction parseDuration(vValue) {\r\n\tif (vValue instanceof Date) {\r\n\t\treturn vValue.getTime();\r\n\t} else if (vValue && vValue.__edmType === \"Edm.Time\") {\r\n\t\treturn vValue.ms;\r\n\t} else if (typeof vValue === \"string\" && parseTimeRE.test(vValue)) {\r\n\t\t/// <summary>Parses a string in xsd:duration format.</summary>\r\n\t\t/// <param name=\"duration\" type=\"String\">Duration value.</param>\r\n\t\t/// <remarks>\r\n\t\t/// This method will return the input, if the input string has a year or a month component.\r\n\t\t/// </remarks>\r\n\t\t/// <returns type=\"Object\">Object representing the time</returns>\r\n\r\n\t\tvar parts = parseTimeRE.exec(vValue);\r\n\r\n\t\tvar years = parts[2] || \"0\";\r\n\t\tvar months = parts[3] || \"0\";\r\n\t\tvar days = parseInt(parts[4] || 0, 10);\r\n\t\tvar hours = parseInt(parts[5] || 0, 10);\r\n\t\tvar minutes = parseInt(parts[6] || 0, 10);\r\n\t\tvar seconds = parseFloat(parts[7] || 0);\r\n\r\n\t\t// Unsupported duration value for Edm.Time OData spec\r\n\t\tif (years !== \"0\" || months !== \"0\") {\r\n\t\t\treturn vValue;\r\n\t\t}\r\n\r\n\t\tvar ms = parts[8];\r\n\t\tif (!ms) {\r\n\t\t\tms = 0;\r\n\t\t} else {\r\n\t\t\t// parse ms duration value ignoring any precision/scale as that part is anyway ignored by JS Date conversion!\r\n\t\t\tms = parseFloat(\"0.\" + ms) * 1000;\r\n\t\t}\r\n\r\n\t\tms += seconds * 1000 + minutes * 60000 + hours * 3600000 + days * 86400000;\r\n\r\n\t\tif (parts[1] === \"-\") {\r\n\t\t\tms = -ms;\r\n\t\t}\r\n\t\tvValue = ms;\r\n\t}\r\n\r\n\treturn vValue;\r\n}\r\n\r\n/** END Copied from datajs * */\r\n\r\n/**\r\n * Gets converted property value from raw data.\r\n * Navigation properties are parsed. Data type values are converted from OData format to JS format (for date types).\r\n * \r\n * @param {Object} oRow - Raw data row\r\n * @param {Object} oCol - Column information\r\n * @param {Array} oCol.keys - Property name or key path for navigation properties\r\n * @param {string} oCol.type - Column data type\r\n * \r\n * @private\r\n */\r\nfunction getValue(oRow, oCol) {\r\n\t// Get property value\r\n\tvar value = oCol.keys.reduce(function (obj, key) {\r\n\t\treturn obj && obj[key];\r\n\t}, oRow);\r\n\t// Convert, if needed.\r\n\tif (value) {\r\n\t\tif (oCol.type === 'date' || oCol.type === 'datetime') {\r\n\t\t\tvalue = parseDate(value);\r\n\t\t} else if (oCol.type === 'time') {\r\n\t\t\tvalue = parseDuration(value);\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Function to process the JSON result array from a ODataService.\r\n * \r\n * @param {Array} aRows - Data array that contains the received data\r\n * @param {Array} aCols - Columns that need to be converted\r\n * \r\n * @private\r\n */\r\nfunction convertData(aRows, aCols) {\r\n\taCols.forEach(function (col) {\r\n\t\taRows.forEach(function (row) {\r\n\t\t\trow[col.property] = getValue(row, col);\r\n\t\t});\r\n\t});\r\n\treturn aRows;\r\n}\r\n\r\n/**\r\n * The function returns array of columns that need special conversion for values.\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n * @private\r\n */\r\nfunction getColsToConvert(mSettings) {\r\n\treturn mSettings.workbook.columns.reduce(function (result, col) {\r\n\r\n\t\t// Handle aggregated properties and single properties\r\n\t\tvar properties = col.property instanceof Array ? col.property : [col.property];\r\n\r\n\t\tproperties.forEach(function(property) {\r\n\t\t\t// Convert navigation property and date fields\r\n\t\t\tvar aKeys = property.split(\"/\");\r\n\t\t\tif (aKeys.length > 1 || col.type === 'date' || col.type === 'datetime' ||  col.type === 'time') {\r\n\t\t\t\tresult.push({\r\n\t\t\t\t\tproperty: property,\r\n\t\t\t\t\tkeys: aKeys,\r\n\t\t\t\t\ttype: col.type\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t}, []);\r\n}\r\n\r\n/**\r\n * The function returns a conversion function for raw data.\r\n *\r\n * @param {Object} mSettings Configuration object\r\n * @returns {function} Conversion function\r\n */\r\nfunction getDataConverter(mSettings) {\r\n\tvar aColumns = getColsToConvert(mSettings);\r\n\treturn function(aRows) {\r\n\t\treturn convertData(aRows, aColumns);\r\n\t};\r\n}\r\n\r\n/**\r\n * The function requests several chunks of data until the maximum\r\n * amount of data is fetched.\r\n *\r\n * @param {Object} mSettings - Configuration object\r\n */\r\nfunction requestData(mSettings, fnProcessCallback) {\r\n\tvar iAvailableRows = 0;\r\n\tvar mDataSource = mSettings.dataSource;\r\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\r\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\r\n\tvar bCancelled = false;\r\n\tvar dataUrl = mDataSource.dataUrl;\r\n\tvar fnConvertData = getDataConverter(mSettings);\r\n\tvar mRequest;\r\n\r\n\tfunction cleanUrl (url) {\r\n\t\tif (!url) return \"\";\r\n\t\tvar mUri = URI.parse(url);\r\n\t\tmUri.path = mUri.path || \"\";\r\n\t\tif (mUri.path.slice(-1) !== \"/\") {\r\n\t\t\tmUri.path = mUri.path + \"/\";\r\n\t\t}\r\n\t\tdelete mUri.query;\r\n\t\tdelete mUri.hash;\r\n\t\tdelete mUri.fragment;\r\n\t\treturn (URI.serialize || URI.build)(mUri);\r\n\t}\r\n\r\n\t// Get download URL for the next batch\r\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\r\n\t\tvar mDataUrl = URI.parse(dataUrl);\r\n\t\tif (sNextUrl) { // use __next from server, replace origin if proxy was used\r\n\t\t\tvar mNextUrl = URI.parse(sNextUrl);\r\n\t\t\tmDataUrl.query = mNextUrl.query;\r\n\t\t} else { // use $skip and $top\r\n\t\t\tvar aQuery = (mDataUrl.query || \"\").split(\"&\");\r\n\t\t\tvar mQuery = {};\r\n\t\t\taQuery.forEach(function(query) {\r\n\t\t\t\tvar keyValue = query.split(\"=\");\r\n\t\t\t\tif (keyValue[0]) {\r\n\t\t\t\t\tmQuery[keyValue[0]] = keyValue[1];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tmQuery[\"$skip\"] = iSkip;\r\n\t\t\tmQuery[\"$top\"] = iTop;\r\n\t\t\taQuery = [];\r\n\t\t\tfor (var key in mQuery) {\r\n\t\t\t\taQuery.push(key + (mQuery[key] == null ? \"\" : \"=\" + mQuery[key]));\r\n\t\t\t}\r\n\t\t\tmDataUrl.query = aQuery.join(\"&\");\r\n\t\t}\r\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes request handler exceptions.\r\n\t *\r\n\t * @param {string} sMessage - Error message.\r\n\t */\r\n\tfunction fnOnError(sMessage) {\r\n\t\tfnProcessCallback({\r\n\t\t\terror: sMessage\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Inner function that processes the received data. Processing\r\n\t * the data before executing the callback function allows to\r\n\t * apply transformations to the data.\r\n\t *\r\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\r\n\t */\r\n\tfunction fnOnDataReceived(oResult) {\r\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\r\n\t\tvar mCallbackParams = {};\r\n\r\n\t\tif (bCancelled) {\r\n\t\t\treturn; // cancelled by the application\r\n\t\t}\r\n\r\n\t\taData = (oResult && oResult.d && (oResult.d.results || oResult.d)) || oResult;\r\n\t\taData = (Array.isArray(aData)) ? aData : [];\r\n\t\tiFetchedRows = aData.length;\r\n\r\n\t\tiAvailableRows += iFetchedRows;\r\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\r\n\t\tfPercent = iAvailableRows / iTotalRows;\r\n\r\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\r\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\r\n\r\n\t\t// check if next url is provided\r\n\t\tsNextUrl = oResult && oResult.d && oResult.d.__next || null;\r\n\r\n\t\tif (!mCallbackParams.finished) {\r\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\r\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\r\n\t\t\tRequestHandler\r\n\t\t\t\t.sendRequest(mRequest)\r\n\t\t\t\t.then(fnOnDataReceived)\r\n\t\t\t\t.catch(fnOnError);\r\n\t\t}\r\n\r\n\t\tmCallbackParams.rows = fnConvertData(aData); // normalize data\r\n\t\tfnProcessCallback(mCallbackParams); // Return result\r\n\t}\r\n\r\n\t// Execution\r\n\tmRequest = {\r\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\r\n\t\tdataUrl: getUrl(0, iBatchSize),\r\n\t\tmethod: mDataSource.useBatch ? \"BATCH\" : \"GET\",\r\n\t\theaders: mDataSource.headers\r\n\t};\r\n\r\n\tRequestHandler\r\n\t\t.sendRequest(mRequest)\r\n\t\t.then(fnOnDataReceived)\r\n\t\t.catch(fnOnError);\r\n\r\n\treturn {cancel: function() {bCancelled = true;}};\r\n}\r\n\r\nmodule.exports = {\r\n\trequestData: requestData,\r\n\tgetConverter: getDataConverter\r\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/ODataDataProvider.js\n// module id = 30\n// module chunks = 1","/**\r\n * Returns a promise that is resolved once the data is fetched\r\n */\r\n\r\nvar HTTP_ERROR_MSG = 'HTTP connection error';\r\n\r\n/**\r\n * This method creates an XMLHttpRequest from the provided\r\n * configuration and requests the data from the backend. The\r\n * configuration is configured to use OData services.\r\n *\r\n * @param {Object} oRequest - Request configuration object\r\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\r\n * @param {string} oRequest.url - References the resource URL that gets invoked\r\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\r\n */\r\nfunction sendRequest(oRequest) {\r\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\r\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\r\n\t}\r\n\r\n\treturn (oRequest.method === \"BATCH\" && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\r\n}\r\n\r\nfunction sendGetRequest(oRequest) {\r\n\treturn new Promise(function (fnResolve, fnReject) {\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\txhr.onload = function () {\r\n\t\t\tif (this.status >= 400) {\r\n\t\t\t\tfnReject(this.responseText);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\r\n\t\t\t} catch (e) {\r\n\t\t\t\tfnReject(\"Server response is not a valid JSON:\\n\" + this.responseText);\r\n\t\t\t}\r\n\t\t};\r\n\t\txhr.onerror = function () {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.onabort = function () {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.open(\"GET\", oRequest.dataUrl, true);\r\n\t\txhr.setRequestHeader(\"accept\", \"application/json\");\r\n\t\txhr.send();\r\n\t});\r\n}\r\n\r\nfunction createGuid() {\r\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n\t\tvar r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\r\n\t\treturn v.toString(16);\r\n\t});\r\n}\r\n\r\nfunction sendBatchRequest(oRequest) {\r\n\treturn new Promise(function (fnResolve, fnReject) {\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\tvar boundary = \"batch_\" + createGuid();\r\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\r\n\t\tvar body = [];\r\n\r\n\t\txhr.onload = function () {\r\n\t\t\tvar responseText = this.responseText;\r\n\t\t\tvar aLines = this.responseText.split(\"\\r\\n\");\r\n\r\n\t\t\t//TBD: check return codes\r\n\t\t\tvar iStart = 0, iLength = aLines.length, iEnd = iLength - 1;\r\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0,1) !== \"{\") {\r\n\t\t\t\tiStart++;\r\n\t\t\t}\r\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== \"}\") {\r\n\t\t\t\tiEnd--;\r\n\t\t\t}\r\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\r\n\t\t\tresponseText = aLines.join(\"\\r\\n\");\r\n\r\n\t\t\ttry {\r\n\t\t\t\tvar responseData = JSON.parse(responseText);\r\n\t\t\t\tfnResolve(responseData);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tfnReject(\"Server response is not a valid JSON\");\r\n\t\t\t}\r\n\t\t};\r\n\t\txhr.onerror = function () {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\txhr.onabort = function () {\r\n\t\t\tfnReject(HTTP_ERROR_MSG);\r\n\t\t};\r\n\t\t// create request\r\n\t\txhr.open(\"POST\", oRequest.serviceUrl + \"$batch\", true);\r\n\r\n\t\txhr.setRequestHeader(\"Accept\", \"multipart/mixed\");\r\n\t\txhr.setRequestHeader(\"Content-Type\", \"multipart/mixed;boundary=\" + boundary);\r\n\r\n\t\tfor (var key in oRequest.headers) {\r\n\t\t\tif (key.toLowerCase() != \"accept\") {\r\n\t\t\t\txhr.setRequestHeader(key, oRequest.headers[key]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tbody.push(\"--\" + boundary);\r\n\t\tbody.push(\"Content-Type: application/http\");\r\n\t\tbody.push(\"Content-Transfer-Encoding: binary\");\r\n\t\tbody.push(\"\");\r\n\t\tbody.push(\"GET \" + getUrl + \" HTTP/1.1\");\r\n\t\tfor (var key in oRequest.headers) {\r\n\t\t\tbody.push(key + \":\" + oRequest.headers[key]);\r\n\t\t}\r\n\t\tbody.push(\"\");\r\n\t\tbody.push(\"\");\r\n\t\tbody.push(\"--\" + boundary + \"--\");\r\n\t\tbody.push(\"\");\r\n\t\tbody = body.join(\"\\r\\n\");\r\n\t\txhr.send(body);\r\n\t});\r\n}\r\n\r\nmodule.exports = { sendRequest: sendRequest };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/RequestHandler.js\n// module id = 31\n// module chunks = 1","/**\r\n * The FileSaver allows to save browser generated files to\r\n * the local computer without using a proxy service.\r\n *\r\n * This class supports the latest version of the following browsers:\r\n *\r\n * Microsoft Internet Explorer 11\r\n * Microsoft Edge\r\n * Google Chrome\r\n * Mozilla Firefox\r\n * MacOS Safari\r\n * iOS Safari\r\n * Chrome for Android\r\n * SAP Fiori Client\r\n */\r\n\r\n/**\r\n * This function saves the provided Blob to the local file system.\r\n * The parameter name is optional and depending on the browser it\r\n * is not ensured that the filename can be applied. Google Chrome,\r\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\r\n * apply the filename correctly.\r\n *\r\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\r\n * @param {string} [name] - Filename of the file including the file extension\r\n */\r\nfunction saveFile(blob, name) {\r\n\tvar link, downloadSupported, fnSave;\r\n\r\n\t/* Ignore other formats than Blob */\r\n\tif (!(blob instanceof Blob)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\r\n\tdownloadSupported = 'download' in link;\r\n\r\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\r\n\tif (downloadSupported) {\r\n\t\tfnSave = function (data, fileName) {\r\n\t\t\tlink.download = fileName;\r\n\t\t\tlink.href = URL.createObjectURL(data);\r\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\r\n\t\t}\r\n\t}\r\n\r\n\t/* iOS Safari, MacOS Safari */\r\n\tif (typeof fnSave === 'undefined') {\r\n\t\tfnSave = function (data) {\r\n\t\t\tvar reader = new FileReader();\r\n\r\n\t\t\treader.onloadend = function () {\r\n\t\t\t\tvar opened, url;\r\n\r\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\r\n\t\t\t\topened = window.open(url, '_blank');\r\n\r\n\t\t\t\tif (!opened) {\r\n\t\t\t\t\twindow.location.href = url;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treader.readAsDataURL(blob);\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t * IE/Edge implementation\r\n\t *\r\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\r\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\r\n\t */\r\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\r\n\t\tfnSave = function (data, fileName) {\r\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\r\n\t\t};\r\n\t}\r\n\r\n\t/* Save file to device */\r\n\tfnSave(blob, name);\r\n}\r\n\r\nmodule.exports = { saveFile: saveFile };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/filesaver/FileSaver.js\n// module id = 32\n// module chunks = 1"],"sourceRoot":""}